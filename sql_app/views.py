from django.shortcuts import render

# Create your views here.
from rest_framework.decorators import api_view
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import SQLProblem, Attempt
from .serializers import SQLProblemListSerializer, SQLProblemDetailSerializer, AttemptSerializer, AttemptHistorySerializer
from utils.sql_sandbox import check_user_query
from rest_framework.permissions import IsAuthenticated
from django.db.models import Count, Case, When, IntegerField, FloatField, ExpressionWrapper, Value, F, Func

@api_view(['GET'])
def problem_list(request):
    """
    Retrieves a list of all available SQL problems.

    This endpoint returns a simplified list of SQL problems, including:
    - Problem ID
    - Title
    - Difficulty level
    - Topic name
    - Acceptance rate (rounded to 2 decimal places)

    The data is ordered by `problem_id` in ascending order.

    Method: GET  
    URL: /api/problems/

    Response Example:
        [
            {
                "problem_id": 1,
                "title": "Find Top Seller",
                "difficulty_level": "Medium",
                "topic": "Aggregation",
                "acceptance": 83.33
            },
            {
                "problem_id": 2,
                "title": "Employees Without Managers",
                "difficulty_level": "Easy",
                "topic": "JOIN",
                "acceptance": 100.0
            }
        ]

    Returns:
        Response: A JSON list of problems serialized via `SQLProblemListSerializer`.
    """
    problems = SQLProblem.objects.annotate(
        total_attempts=Count("attempts"),
        successful_attempts=Count(
            Case(
                When(attempts__status="Completed", then=1),
                output_field=IntegerField()
            )
        ),
        raw_acceptance=ExpressionWrapper(
            Case(
                When(total_attempts__gt=0,
                    then=F('successful_attempts') * 100.0 / F('total_attempts')),
                default=Value(0.0),
                output_field=FloatField()
            ),
            output_field=FloatField()
        ),
        acceptance=Func(F('raw_acceptance'), function='ROUND', template='ROUND(%(expressions)s, 2)')
    ).order_by('problem_id')

    serializer = SQLProblemListSerializer(problems, many=True)
    return Response(serializer.data)

@api_view(['GET'])
def problem_detail(request, problem_id):
    """
    Retrieves detailed information for a specific SQL problem.

    This endpoint returns comprehensive data about the problem, including:
    - Title, description, and difficulty level
    - Topic name
    - Whether result order matters
    - Table schemas
    - Hints
    - Expected output (generated by running solution.sql)

    Method: GET  
    URL: /api/problems/<problem_id>/

    Parameters:
        problem_id (int): The ID of the SQL problem to retrieve.

    Responses:
        200 OK:
            {
                "problem_id": 3,
                "title": "Find Active Users",
                "description": "...",
                "difficulty_level": "Medium",
                "topic": "JOIN",
                "requires_order": false,
                "tables": [...],
                "input_data",
                "hints": [...],
                "expected_output": [...],
                "acceptance": value (float)
            }

        404 Not Found:
            {
                "error": "Problem not found."
            }

    Returns:
        Response: A JSON object with full problem details serialized using `SQLProblemDetailSerializer`.
    """
    try:
        problem = SQLProblem.objects.get(problem_id=problem_id)
    except SQLProblem.DoesNotExist:
        return Response({"error": "Problem not found."}, status=status.HTTP_404_NOT_FOUND)

    serializer = SQLProblemDetailSerializer(problem)
    return Response(serializer.data)

class AttemptSubmitView(APIView):
    """
    Handles the submission of a user's SQL query for a specific problem.

    Endpoint: POST /api/problems/<problem_id>/submit/

    Features:
    - Requires authentication via `IsAuthenticated`.
    - Accepts the user's query and optional metadata (e.g., hints used, time taken).
    - Validates and checks the SQL query in a sandboxed environment.
    - Computes score and status based on correctness.
    - Saves the result as an Attempt object.
    - Returns feedback and result status in the response.

    Request Body:
        {
            "user_query": "SELECT * FROM ...",
            "hints_used": 1,          # optional
            "time_taken": 120         # optional
        }

    Successful Response (200 OK):
        {
            "result": "correct",
            "score": 100,
            "feedback": ""
        }

    Failure Response (400 / 404):
        {
            "error": "Problem not found."
        }

        OR

        {
            "user_query": ["This field is required."]
        }

    Parameters:
        problem_id (int): The ID of the SQL problem being attempted.

    Permissions:
        - Requires the user to be authenticated.
    """
    permission_classes = [IsAuthenticated]

    def post(self, request, problem_id):
        user = request.user
        try:
            problem = SQLProblem.objects.get(problem_id=problem_id)
        except SQLProblem.DoesNotExist:
            return Response({"error": "Problem not found."}, status=status.HTTP_404_NOT_FOUND)

        serializer = AttemptSerializer(data=request.data, partial=True)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        data = serializer.validated_data
        user_query = data.get("user_query")
        hints_used = data.get("hints_used", 0)
        time_taken = data.get("time_taken", None)

        # Run sandboxed check on the user's SQL query
        correct, message = check_user_query(problem_id, user_query)

        score = 100 if correct else 0
        status_str = "Completed" if correct else "Failed"

        # Save the attempt record
        attempt = serializer.save(
            user=user,
            problem=problem,
            score=score,
            status=status_str,
            hints_used=hints_used,
            time_taken=time_taken
        )

        return Response({
            "result": "correct" if correct else "wrong",
            "score": score,
            "feedback": message
        }, status=status.HTTP_200_OK)


class AttemptHistoryView(APIView):
    """
    API endpoint to retrieve a user's submission history for a specific SQL problem.

    Method:
        GET

    URL:
        /api/problems/<problem_id>/history/

    Permissions:
        - Requires authentication (JWT token)

    Request Parameters:
        - problem_id (int): The ID of the SQL problem

    Behavior:
        - Checks if the problem exists
        - Retrieves all attempts made by the current user for the specified problem
        - Orders attempts by submission date (most recent first)

    Response (200 OK):
        Returns a list of attempt records with the following fields:
        [
            {
                "submission_date": "2024-04-01T14:32:00Z",
                "score": 100.0,
                "time_taken": 120,
                "status": "Completed",
                "hints_used": 1
            },
            ...
        ]

    Response (404 Not Found):
        {
            "error": "Problem not found"
        }
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, problem_id):
        user = request.user

        # Check if the problem exists
        try:
            problem = SQLProblem.objects.get(problem_id=problem_id)
        except SQLProblem.DoesNotExist:
            return Response({"error": "Problem not found"}, status=status.HTTP_404_NOT_FOUND)

        # Retrieve the user's submission history for this problem (ordered by most recent)
        attempts = Attempt.objects.filter(user=user, problem=problem).order_by('-submission_date')
        serializer = AttemptHistorySerializer(attempts, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)