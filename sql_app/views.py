from django.shortcuts import render

# Create your views here.
from rest_framework.decorators import api_view
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import SQLProblem
from .serializers import SQLProblemListSerializer, SQLProblemDetailSerializer, AttemptSerializer
from utils.sql_sandbox import check_user_query
from rest_framework.permissions import IsAuthenticated

@api_view(['GET'])
def problem_list(request):
    """
    Retrieves a list of all available SQL problems.

    This endpoint returns a simplified list of SQL problems, including:
    - Problem ID
    - Title
    - Difficulty level
    - Topic name

    The data is ordered by `problem_id` in ascending order.

    Method: GET  
    URL: /api/problems/

    Response Example:
        [
            {
                "problem_id": 1,
                "title": "Find Top Seller",
                "difficulty_level": "Medium",
                "topic": "Aggregation"
            },
            {
                "problem_id": 2,
                "title": "Employees Without Managers",
                "difficulty_level": "Easy",
                "topic": "JOIN"
            }
        ]

    Returns:
        Response: A JSON list of problems serialized via `SQLProblemListSerializer`.
    """
    problems = SQLProblem.objects.all().order_by('problem_id')
    serializer = SQLProblemListSerializer(problems, many=True)
    return Response(serializer.data)

@api_view(['GET'])
def problem_detail(request, problem_id):
    """
    Retrieves detailed information for a specific SQL problem.

    This endpoint returns comprehensive data about the problem, including:
    - Title, description, and difficulty level
    - Topic name
    - Whether result order matters
    - Table schemas
    - Hints
    - Expected output (generated by running solution.sql)

    Method: GET  
    URL: /api/problems/<problem_id>/

    Parameters:
        problem_id (int): The ID of the SQL problem to retrieve.

    Responses:
        200 OK:
            {
                "problem_id": 3,
                "title": "Find Active Users",
                "description": "...",
                "difficulty_level": "Medium",
                "topic": "JOIN",
                "requires_order": false,
                "tables": [...],
                "hints": [...],
                "expected_output": [...]
            }

        404 Not Found:
            {
                "error": "Problem not found."
            }

    Returns:
        Response: A JSON object with full problem details serialized using `SQLProblemDetailSerializer`.
    """
    try:
        problem = SQLProblem.objects.get(problem_id=problem_id)
    except SQLProblem.DoesNotExist:
        return Response({"error": "Problem not found."}, status=status.HTTP_404_NOT_FOUND)

    serializer = SQLProblemDetailSerializer(problem)
    return Response(serializer.data)

class AttemptSubmitView(APIView):
    """
    Handles the submission of a user's SQL query for a specific problem.

    Endpoint: POST /api/problems/<problem_id>/submit/

    Features:
    - Requires authentication via `IsAuthenticated`.
    - Accepts the user's query and optional metadata (e.g., hints used, time taken).
    - Validates and checks the SQL query in a sandboxed environment.
    - Computes score and status based on correctness.
    - Saves the result as an Attempt object.
    - Returns feedback and result status in the response.

    Request Body:
        {
            "user_query": "SELECT * FROM ...",
            "hints_used": 1,          # optional
            "time_taken": 120         # optional
        }

    Successful Response (200 OK):
        {
            "result": "correct",
            "score": 100,
            "feedback": ""
        }

    Failure Response (400 / 404):
        {
            "error": "Problem not found."
        }

        OR

        {
            "user_query": ["This field is required."]
        }

    Parameters:
        problem_id (int): The ID of the SQL problem being attempted.

    Permissions:
        - Requires the user to be authenticated.
    """
    permission_classes = [IsAuthenticated]

    def post(self, request, problem_id):
        user = request.user
        try:
            problem = SQLProblem.objects.get(problem_id=problem_id)
        except SQLProblem.DoesNotExist:
            return Response({"error": "Problem not found."}, status=status.HTTP_404_NOT_FOUND)

        serializer = AttemptSerializer(data=request.data, partial=True)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        data = serializer.validated_data
        user_query = data.get("user_query")
        hints_used = data.get("hints_used", 0)
        time_taken = data.get("time_taken", None)

        # Run sandboxed check on the user's SQL query
        correct, message = check_user_query(problem_id, user_query)

        score = 100 if correct else 0
        status_str = "Completed" if correct else "Failed"

        # Save the attempt record
        attempt = serializer.save(
            user=user,
            problem=problem,
            score=score,
            status=status_str,
            hints_used=hints_used,
            time_taken=time_taken
        )

        return Response({
            "result": "correct" if correct else "wrong",
            "score": score,
            "feedback": message
        }, status=status.HTTP_200_OK)
